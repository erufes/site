---
title: Desenvolvendo com Docker + ROS2
classes: wide
categories:
  - Tecnologia
tags:
  - ROS2
  - Docker
  - Tutorial
author: pietroluongo
toc: true
toc_icon: cog
toc_label: √çndice
---

Ok, ent√£o voc√™ quer desenvolver usando Docker e ROS2, mas acabou esbarrando no abismo que s√£o os problemas gerais de integra√ß√£o entre diferentes m√°quinas virtualizadas, dispositivos, comunica√ß√£o...
Nesse caso, esse tutorial aqui foi feito exatamente pra voc√™! Pra n√£o perdermos tempo, vou assumir que voc√™ j√° tem um conhecimento b√°sico acerca de ROS e Docker, mas teve problemas pra conseguir um ambiente de desenvolvimento agrad√°vel usando essas duas ferramentas - de fato: uma parte extremamente importante do desenvolvimento √© o ambiente no qual ele acontece. Ent√£o chega de ficar rodando sess√µes de _bash_ dentro de 10 _containers_ separados que fecham em todo c√≥digo de sa√≠da n√£o usual, chega de criar um _container_ novo sem querer pra cada teste que voc√™ tenta fazer com o seu c√≥digo e chega de programar dentro de ambiente diretamente virtualizado, vamos simplificar as coisas!
Por fim, vale ressaltar que para esse tutorial, vamos usar o c√≥digo em Python, mas √© poss√≠vel fazer ele funcionar de forma similar usando c√≥digo em C++.

# Prepara√ß√£o

## O que voc√™ precisa

- Docker instalado, evidentemente
- docker-compose, permitindo a orquestra√ß√£o de _containers_
- Um editor de texto - eu recomendo o VSCode, e √© o que vai ser usado nesse guia
- make
- WSL, se estiver trabalhando no windows
- Paci√™ncia

## Ok, por onde eu come√ßo?

Considerando que voc√™ j√° instalou o que t√° listado ali em cima, voc√™ precisa inicialmente criar o seu ambiente de desenvolvimento. A arquitetura proposta aqui √© usar dois (ou mais) _containers_: um para o seu c√≥digo e um com as ferramentas de desenvolvimento. Para possibilitar o acesso de arquivos na sua m√°quina local a partir da sua m√°quina virtualizada, usamos o conceito de **volumes**.
Antes de come√ßar de fato, crie uma pasta em seu diret√≥rio `$HOME` chamada `ros`. Essa √© a pasta que ir√° conter os arquivos criados abaixo e, futuramente, o _workspace_ do ROS2.

## Mais especificamente, qual problema vamos resolver?

Pra simplificar, vamos pegar um problema simples: rodar o _turtlesim_ com um algoritmo de controle implementado por voc√™. Assume-se que voc√™ j√° tem familiaridade com o turtlesim - caso contr√°rio, h√° bastante material dispon√≠vel na internet. Sugest√£o: [use esse link aqui](https://docs.ros.org/en/foxy/Tutorials/Beginner-CLI-Tools/Introducing-Turtlesim/Introducing-Turtlesim.html).

# Inicializando o ambiente de desenvolvimento

## Dockerfile do sistema de ferramentas

Primeiramente, vamos precisar montar um _container_ que consiga executar bin√°rios do ROS2. Em particular, esses _container_ ser√° usado para conter as ferramentas e bibliotecas de desenvolvimento. Para isso, usamos um _Dockerfile_ customizado.

> O _Dockerfile_ √© um arquivo contendo instru√ß√µes para o docker montar um _container_ a partir de uma imagem base.

Para esse artigo, vamos partir da imagem oficial padr√£o do ROS2.

```Dockerfile
FROM osrf/ros:humble-desktop-full


RUN curl https://bootstrap.pypa.io/get-pip.py > get-pip.py

RUN python3 get-pip.py


RUN echo ". /ros_entrypoint.sh" >> ~/.bashrc

RUN echo "source /root/ros_ws/install/setup.bash" >> ~/.bashrc

# Rospy2

RUN git clone https://github.com/dheera/rospy2.git

RUN cd rospy2 && python3 setup.py install

# Keep alive
CMD ["tail", "-f", "/dev/null"]
```

Vamos analisar o _Dockerfile_ acima:

Partindo da imagem padr√£o do _ROS humble_, instalamos, por conveni√™ncia, o _pip_:

```Dockerfile
FROM osrf/ros:humble-desktop-full

RUN curl https://bootstrap.pypa.io/get-pip.py > get-pip.py

RUN python3 get-pip.py

```

> Evidentemente, caso v√° trabalhar com C++, os comandos de instala√ß√£o do pip s√£o desnecess√°rios.

Em seguida, adicionamos ao arquivo `.bashrc` as instru√ß√µes de inicializa√ß√£o do ROS2, simplificando os comandos a serem executados:

```Dockerfile
RUN echo ". /ros_entrypoint.sh" >> ~/.bashrc

RUN echo "source /root/ros_ws/install/setup.bash" >> ~/.bashrc
```

> O `.bashrc` √© um arquivo usado pelo Linux para inicializa√ß√£o do shell. Nesse caso, queremos que o linux inicialize com os comandos do ROS2 j√° preparados - caso contr√°rio, seria necess√°rio executar exatamente os dois comandos descritos acima toda vez que o shell fosse iniciado.

Al√©m de inicializar o ROS2, tamb√©m _instalamos_ os n√≥s "compilados" - com isso, apenas abrir um console dentro da m√°quina virtualizada j√° √© suficiente para rodar o seu c√≥digo ou um bin√°rio de ROS2 qualquer.

Em seguida, instalamos o rospy, disponibilizando mais algumas bibliotecas nos c√≥digos. Esse passo √© tamb√©m opcional para o trabalho em C++.

```Dockerfile
# Rospy2

RUN git clone https://github.com/dheera/rospy2.git

RUN cd rospy2 && python3 setup.py install
```

Por fim, executamos um comando `tail -f /dev/null`, que garante que o _container_ se mantenha em execu√ß√£o independente do que aconte√ßa - isso √© necess√°rio pois caso contr√°rio n√£o seria poss√≠vel executar um terminal dentro do _container_, j√° que ele n√£o estaria em execu√ß√£o ao emitir o comando.

```Dockerfile
# Keep alive
CMD ["tail", "-f", "/dev/null"]
```

> Perceba que o Dockerfile n√£o cont√©m instru√ß√µes de volumes. N√≥s vamos configurar isso no arquivo de docker-compose.

---

Nesse ponto, √© poss√≠vel executar um comando de _build_ manual a partir desse _Dockerfile_ e rodar, por exemplo, o _turtlesim_ ou um sistema que voc√™ mesmo desenvolveu. Contudo, o objetivo √© automatizar essas tarefas, ent√£o usamos um orquestrador de containers.

## Configurando o docker-compose

Para inicializar as m√°quinas virtuais e "lig√°-las" virtualmente, usaremos o seguinte arquivo de docker-compose:

```yml
version: '3.3'

services:
¬† simulator:
¬† ¬† image: osrf/ros:humble-desktop-full
¬† ¬† devices:
¬† ¬† ¬† - /dev/dri
¬† ¬† container_name: ros_turtlebot_sim
¬† ¬† environment:
¬† ¬† ¬† - 'DISPLAY=host.docker.internal:0.0'
¬† ¬† volumes:
¬† ¬† ¬† - '$HOME/.Xauthority:/root/.Xauthority:ro'
¬† ¬† ¬† - '$HOME/ros_ws:/root/ros_ws/'
¬† ¬† command: ros2 run turtlesim turtlesim_node
¬† tooling:
¬† ¬† build:
¬† ¬† ¬† dockerfile: ./Dockerfile
¬† ¬† container_name: ros_tools
¬† ¬† volumes:
¬† ¬† ¬† - '$HOME/ros_ws:/root/ros_ws'
¬† ¬† command: "tail -f /dev/null"
```

> De forma similar ao Dockerfile, o docker-compose informa ao sistema de orquestra√ß√£o o que exatamente deve ser feito para inicializar o sistema - nesse caso, "sistema" se refere ao conjunto de m√°quinas virtualizadas.

Novamente, vamos analisar em partes menores:

```yml
version: '3.3'

services:
¬† simulator:
	¬† ...
  tooling:
	  ...
```

Iniciamos definindo que usaremos a vers√£o `3.3` do _docker-compose_ - isso √© padr√£o e n√£o √© importante para n√≥s no momento. Em seguida, definimos que esse arquivo ir√° prover dois servi√ßos: um com o simulador (o _turtlesim_) e um com as ferramentas de desenvolvimento, denominado _tooling_.

### O servi√ßo de simula√ß√£o

```yml
image: osrf/ros:humble-desktop-full
¬† ¬† devices:
¬† ¬† ¬† - /dev/dri
¬† ¬† container_name: ros_turtlebot_sim
¬† ¬† environment:
¬† ¬† ¬† - 'DISPLAY=host.docker.internal:0.0'
¬† ¬† volumes:
¬† ¬† ¬† - '$HOME/.Xauthority:/root/.Xauthority:ro'
¬† ¬† ¬† - '$HOME/ros_ws:/root/ros_ws/'
¬† ¬† command: ros2 run turtlesim turtlesim_node
```

Primeiramente, informamos que a imagem a ser usada no _container_ √© a `osrf/ros:humble-desktop-full` - ou seja: a imagem padr√£o do _ROS2 humble_. Em seguida, definimos algumas informa√ß√µes na m√°quina virtual: informamos ao virtualizador a exist√™ncia do _device_ `/dev/dri`, relacionado ao _pipeline_ de renderiza√ß√£o do linux; definimos que o _container_ criado ter√° o nome `ros_turtlebot_sim` - esse nome pode ser alterado sem problemas; definimos a vari√°vel de ambiente que descreve o endere√ßo da interface de display com `host.docker.internal:0.0` - nesse caso, como o desenvolvimento acontece no WSL (Subsistema Windows para Linux), √© necess√°rio "conectar" o display do Windows com o display virtualizado; definimos os volumes `'$HOME/.Xauthority:/root/.Xauthority:ro'` - ou seja: "a pasta virtualizada `/root/.Xauthority` √© mapeada na pasta 'real' `$HOME/.Xauthority`, e a pasta 'real' `$HOME/ros_ws` √© mapeada na pasta virtual `/root/ros_ws/`". Por fim, informamos ao _container_ que ao iniciar, deve ser executado o comando `ros2 run turtlesim turtlesim_node` - com isso, apenas inicializar o container j√° √© suficiente para ele rodar o simulador automaticamente.

> Na se√ß√£o acima, usamos "pasta real" para nos referir a uma pasta no seu pr√≥prio sistema operacional - ou seja, no seu pr√≥prio computador, enquanto usamos "pasta virtual" para nos referir a pastas que est√£o localizadas dentro do _container_ relevante.

Ufa! Conseguimos, ent√£o, explicar pro _docker_ como iniciar o sistema de simula√ß√£o - mas ainda falta o sistema de desenvolvimento com as ferramentas, que √© o nosso segundo servi√ßo.

### O servi√ßo de desenvolvimento

```yml
¬† ¬† build:
¬† ¬† ¬† dockerfile: ./Dockerfile
¬† ¬† container_name: ros_tools
¬† ¬† volumes:
¬† ¬† ¬† - '$HOME/ros_ws:/root/ros_ws'
¬† ¬† command: "tail -f /dev/null"
```

Esse arquivo parece mas simples - mas s√≥ porque a complexidade toda que apareceria aqui est√°, na verdade, no `Dockerfile` que configuramos anteriormente. De fato, aqui falamos ao _docker_ que a imagem base que usaremos n√£o √© a do ROS2 igual fizemos anteriormente, mas sim a definida no arquivo `./Dockerfile`! Perceba tamb√©m que h√° uma tag `build`, informando que essa imagem deve ser constru√≠da a partir do arquivo passado. No mais, as instru√ß√µes s√£o similares √†s descritas anteriormente: defina o nome do _container_, mapeie os volumes, e use o comando padr√£o para manter a m√°quina virtual em execu√ß√£o indefinidamente.

ConseguimosüòÉ! Agora √© s√≥ executar as instru√ß√µes desse arquivo.

---

### Estrutura atual de arquivos

Nesse momento, deve existir a seguinte estrutura de arquivos:

```
$HOME/
‚îú‚îÄ ros/
‚îÇ  ‚îú‚îÄ Dockerfile
‚îÇ  ‚îú‚îÄ docker-compose.yml
```

Vamos testar o funcionamento!

# Usando o sistema

Comece entrando na pasta `ros` na estrutura acima e execute

```bash
docker-compose up -d
```

> A flag `-d` indica que a tarefa de composi√ß√£o deve ocorrer em background, sem bloquear o seu shell.

Com isso, deve ser poss√≠vel executar o seguinte comando para listar os _containers_ em execu√ß√£o:

```bash
docker ps
```

E a sa√≠da deve ser algo similar a

```
CONTAINER ID   IMAGE                                      COMMAND                  CREATED       STATUS        PORTS                    NAMES
98b9c5ea0f1e   rostests-tooling                           "/ros_entrypoint.sh ‚Ä¶"   2 weeks ago   Up 1 second                            ros_tools
25e4fac967f5   osrf/ros:humble-desktop-full               "/ros_entrypoint.sh ‚Ä¶"   2 weeks ago   Up 1 second                            ros_turtlebot_sim
```

Se tudo tiver dado certo, uma janela com o _turtlesim_ deve ter aparecido. Nesse caso, parab√©ns! Voc√™ conseguiu rodar uma aplica√ß√£o ROS2 mesmo sem instalar nada associado no seu computador! üòÅ

> Se a janela do _turtlesim_ n√£o tiver aparecido, √© uma boa ideia tentar rodar o `docker-compose` novamente mas sem a flag `-d`. Isso permite voc√™ dar uma olhada em qualquer mensagem de erro que tenha aparecido no meio do caminho.

---

Nesse est√°gio j√° √© poss√≠vel acessar o ambiente de desenvolvimento de fato - e √© exatamente isso que vamos fazer para inicializar nosso _workspace_:

```bash
docker exec -it ros_tools bash
```

Aqui voc√™ est√° dentro do seu container. Lembre-se que mapeamos a sua pasta 'real' para a pasta 'virtual' em `/root/ros_ws` - acesse essa pasta.

```bash
cd /root/ros_ws
```

> Note que √© poss√≠vel acessar os comandos de ROS2 imediatamente do seu shell, mesmo sem ter executado nenhum script.

Agora vamos inicializar seu projeto. Execute o seguinte comando dentro da pasta `/root/ros_ws`:

```bash
ros2 pkg create --build-type ament_python py_pubsub
```

Isso ir√° criar um pacote de nome `py_pubsub`. A flag `--build-type ament_python` informa ao ROS2 qual o tipo de pacote a se criar (e qual a linguagem que √© utilizada por ele). Voc√™ pode construir os n√≥s a partir do seguinte comando de dentro da pasta `ros_ws`:

```bash
colcon build
```

Verifique que a seguinte estrutura de arquivos existe na sua m√°quina virtual:

```
root/
‚îú‚îÄ ros_ws/
‚îÇ  ‚îú‚îÄ build/
‚îÇ  ‚îú‚îÄ install/
‚îÇ  ‚îú‚îÄ log/
‚îÇ  ‚îú‚îÄ py_pubsub/
```

As pastas relevantes no momento s√£o a `py_pubsub`, que cont√©m o c√≥digo fonte dos seus n√≥s, e a `install`, que cont√©m os scripts de instala√ß√£o desses n√≥s.

> Perceba que ainda n√£o temos acesso aos bin√°rios dos n√≥s. Isso acontece porque o script de inicializa√ß√£o tenta "instalar" o acesso aos n√≥s antes deles existirem de fato. Isso ocorre exclusivamente nessa primeira execu√ß√£o da m√°quina virtual - futuramente, usaremos um _Makefile_ para automatizar esses processos.

Outro ponto importante √© perceber que essa estrutura √© refletida na sua m√°quina local:

```
$HOME/
‚îú‚îÄ ros_ws/
‚îÇ  ‚îú‚îÄ build/
‚îÇ  ‚îú‚îÄ install/
‚îÇ  ‚îú‚îÄ log/
‚îÇ  ‚îú‚îÄ py_pubsub/
```

Isso ocorre por causa dos volumes, conforme comentado anteriormente.

## Ciclo de desenvolvimento

O objetivo principal desse guia √© simplificar o processo de desenvolvimento, e ficar rodando `docker exec bash` constantemente n√£o √© exatamente produtivo. Qual a solu√ß√£o, ent√£o? Inicialmente, podemos concatenar os comandos de compila√ß√£o e execu√ß√£o, o que j√° ajuda bastante!

### Comandos de compila√ß√£o e execu√ß√£o combinados

Conforme vimos anteriormente precisamos, sequencialmente:

1. Entrar no _container_ e abrir um terminal - `docker exec -it ros_tools bash`
2. Ativar os ambiente do ROS2 - `source /ros_entrypoint.sh`
3. Instalar os n√≥s relevantes - `source /root/ros_ws/install/setup.bash`
4. Compilar o n√≥ OU Executar o n√≥ associado - `ros2 run py_pubsub bin`
   > Em `ros2 run py_pubsub bin`, `bin` √© o nome do bin√°rio associado. Caso isso n√£o esteja claro, d√™ uma olhada nos tutoriais de ROS2 que explicam sobre o comando `ros2 pkg create`.

Jutando todos os comandos descritos acima, temos o comando de compila√ß√£o:

```bash
docker exec -it ros_tools bash -c "source /ros_entrypoint.sh && cd /root/ros_ws && colcon build"
```

A _flag_ `-c` indica que o comando est√° sendo passado como uma string, permitindo o uso como descrito acima.

> Nesse caso aqui a gente precisa manualmente ativar o ambiente de desenvolvimento e "instalar" os n√≥s porque a invoca√ß√£o do `bash` direto do terminal como foi feito n√£o executa o script `.bashrc`, conforme discutido anteriormente.

Por outro lado e seguindo a mesma l√≥gica, podemos executar um n√≥:

```bash
docker exec -it ros_tools bash -c "source /ros_entrypoint.sh && source /root/ros_ws/install/setup.bash && ros2 run py_pubsub bin"
```

### Simplificando o desenvolvimento com um Makefile

Digitar um comando desse tamanho d√° muito trabalho, ent√£o podemos automatizar grande parte das tarefas usando um _Makefile_ simples!

> Um _Makefile_ √© um script usado em geral para simplificar tarefas de compila√ß√£o de c√≥digo. Aqui vamos usar para simplificar a compila√ß√£o e a execu√ß√£o.

Crie um arquivo chamado `Makefile` com o seguinte conte√∫do:

```Makefile
all: run

build:
¬† ¬† docker exec -it ros_tools bash -c "source /ros_entrypoint.sh && cd /root/ros_ws && colcon build"
¬† ¬†
run: build
¬† ¬† docker exec -it ros_tools bash -c "source /ros_entrypoint.sh && source /root/ros_ws/install/setup.bash && ros2 run turtle_control_${TURTLE_CONTROL_NAME} turtle_control"
```

Simplificando: caso n√£o conhe√ßa o _Makefile_, considere que as linhas terminadas em "`:`" s√£o comandos - o nome t√©cnico de um comando √© "alvo", ou `target`. Podemos, ent√£o, executar algo como

```bash
make build
```

E seria equivalente ao comando de compila√ß√£o original acima.

Pronto! Agora, podemos abrir um c√≥digo Python na pasta `py_pubsub` com o VSCode, edit√°-lo como preferirmos e salv√°-lo. Depois de salvar, basta executar
`make` no terminal que o computador re-compila e re-executa o seu programa. M√°gico!

> A chamada de `make` sem nenhum par√¢metro executa o `target` padr√£o. No caso desse _Makefile_, √© o `all`. Analisando o conte√∫do do arquivo, √© percept√≠vel que o alvo `all` n√£o faz nada al√©m de chamar o alvo `run`, que executa o c√≥digo. √â mais uma otimiza√ß√£o de desenvolvimento üòâ.

---

# Configurando o VSCode para desenvolvimento

A configura√ß√£o do VSCode √© bem direta, e consiste basicamente na instala√ß√£o de algumas extens√µes auxiliares. Nativamente, ele j√° consegue realizar conex√µes em ambientes de trabalho remotos, o que facilita bastante a nossa vida.

## Extens√µes

O ponto principal dessa se√ß√£o √© instalar a [extens√£o do docker](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-docker) e [a extens√£o do ROS](https://marketplace.visualstudio.com/items?itemName=ms-iot.vscode-ros). Inicialmente, instale apenas a extens√£o do docker, pois o ROS deve ser instalado apenas dentro do _container_ de desenvolvimento.

Abra a aba lateral do Docker, e conecte seu VSCode com o _container_ de desenvolvimento:

{% include centered_figure image_path="/assets/imgs/posts/tech/ros2_docker/ros2_attach.png" alt="Conectando com o *container* de dentro do VSCode." caption="Conectando com o *container* de dentro do VSCode." style="width:20rem" %}

Isso deve abrir uma nova janela dentro do seu _container_. Nesse caso, voc√™ est√° rodando um VSCode na sua m√°quina que est√°, na verdade, rodando dentro da sua m√°quina virtual. Incr√≠vel, n√£o?

Agora, no VSCode aberto dentro do seu _container_, instale [a extens√£o do Python](https://marketplace.visualstudio.com/items?itemName=ms-python.python) (ou [a do C++](https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools), caso v√° trabalhar nessa linguagem).

Executando dessa forma, voc√™ consegue desenvolver com ajuda do Intellisense e todas as outras _features_ incr√≠veis que editores modernos proporcionam:

{% include centered_figure image_path="/assets/imgs/posts/tech/ros2_docker/ros2_intellisense.png" alt="Intellisense no VSCode dentro do Docker." caption="Intellisense no VSCode dentro do Docker." style="width:20rem" %}

Agora √© s√≥ aproveitar isso tudo e mandar ver no que voc√™ precisar fazer!

# Conclus√£o

Ao longo desse guia:

- Criamos um _container_ Docker com ROS2, o ambiente de simula√ß√£o e todas as suas depend√™ncias;
- Criamos um _container_ Docker com o ambiente de desenvolvimento;
- Criamos um _Makefile_ para facilitar o desenvolvimento;
- Configuramos o VSCode para desenvolver dentro do _container_ de desenvolvimento;

Espero que esse guia tenha sido √∫til para voc√™, e que voc√™ consiga aproveitar ao m√°ximo o ROS2 e o Docker para desenvolver seus projetos! Se voc√™ tiver alguma d√∫vida, sugest√£o ou cr√≠tica, fique a vontade para entrar em contato comigo! üòâ
